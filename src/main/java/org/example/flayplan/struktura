AirspaceAuthority:
Этот класс представляет орган управления воздушным пространством,
содержащий базовую информацию, такую как имя, регион и контактные данные. Он служит для указания,
какие органы власти связаны с определенными полетами, и выступает как справочник при получении
одобрений для полетных планов.

Approval:
Эта модель связана с одобрениями от властей для полета. Она содержит статус одобрения, детали, кто
его утвердил, комментарии, и связывается с AirspaceAuthority, чтобы обозначить, какая именно власть
отвечает за одобрение.

AuditLog:
Лог действий (AuditLog) фиксирует все выполненные действия в системе (например, изменение
статуса полета, обновления от органов власти и т.д.). Он хранит сведения об исполнителе и времени
действия, что полезно для аудита.

FlightPlan:
Центральная модель системы, представляющая план полета. Она хранит информацию о рейсе,
маршруте, времени отправления и прибытия, статусе полета и связанных с ним воздушных властях.
Полет может быть связан с Pilot и списком точек маршрута (Waypoint). Также здесь хранится информация
об утверждении (Approval), если разрешение от воздушных властей получено.

Pilot:
Класс для представления информации о пилоте, который связан с планом полета. Содержит контактные данные
и лицензию пилота.

Waypoint:
Определяет координаты маршрута для FlightPlan. Каждый Waypoint содержит координаты (широту, долготу) и
высоту, и используется для построения маршрута полета.

Основная цель:
1)Отправка JSON через RabbitMQ Management
выбираю очередь approval.requests.queue
2)Consumer получает сообщение
тот, кто подписан на эту очередь, получит сообщение
и десериализует его в объект ApprovalDTO
3)Обработка сообщения:
Consumer проверяет статус, указанный в полученном
JSON(status:"APPROVED")
Если статус воздушного плана FlightPlan в базе данных
был "PENDING", он обновляется на "APPROVED"
4)Обновление данных в базе:
Consumer созраняет

Отправка сообщения из FlayPlan:

В ServiceImpl (FlayPlan проект) вы обновляете статус Approval и отправляете сообщение через RabbitMQ (ApprovalProducer).
Это сообщение помещается в очередь RabbitMQ (например, approval.requests.queue), чтобы Consumer его обработал.
Обработка сообщения в Consumer:

Consumer получает сообщение из очереди и выполняет предварительную обработку (логирование, валидация и т.д.).
Если требуется обновить статус в базе данных, Consumer отправляет новое сообщение обратно в RabbitMQ (например, в очередь flayplan.update.queue), чтобы FlayPlan-сервис сам выполнил обновление данных.
Обновление данных в FlayPlan:

В FlayPlan проекте у вас есть FlayPlanConsumer, который слушает очередь flayplan.update.queue.
Когда приходит сообщение об изменении статуса, в ServiceImpl вызывается метод, который обновляет статус Approval и FlightPlan в базе данных.
